# Documentation

## Problem description
The "Maximum density still life" problem arises from John Horton Conway's Game of Life. The game is played on an (in theory) infinitely squared grid where each cell is either alive or dead. The state of the board evolves in discrete timesteps according to the number of living neighbors (horizontal, vertical, and diagonal) a cell has:

- A live cell with exactly 2 or 3 live neighbors stays alive.
- A dead cell with exactly 3 live neighbors becomes alive.
- All other cells die or remain dead.

A Still-Life is a pattern that does not change from one timestep to the next. The optimization problem asks: What is the maximum number of live cells that can be placed in an $n \times n$ grid such that the pattern is a stable Still-Life and all cells outside the $n \times n$ box are dead?

## Encoding

The problem is encoded using two sets of variables. Variables $Cell(r,c)$ represent that the cell at row $r$ and column $c$ is Alive. 

Variables $Ge(k, N_{x})$ represent that the set of cells $N_{x}$ (the neighbors of position $x$) contains at least $k$ alive cells. These are auxiliary variables generated by unary counter logic circuits to perform summation within the SAT formula.

To represent the decision problem of finding a valid Still-Life pattern with a minimum population of $P$, we use the following constraints:

 - Stability of Alive Cells
If a cell is alive, it must have exactly 2 or 3 alive neighbors to remain alive (survive).
$$Cell(r,c) \implies (Ge(2, N_{r,c}) \wedge \neg Ge(4, N_{r,c}))$$
for each $r, c \in \{0 \dots N-1\}$.
- Stability of Dead Cells
If a cell is dead, it must not have exactly 3 alive neighbors (which would cause a birth).
$$\neg Cell(r,c) \implies \neg(Ge(3, N_{r,c}) \wedge \neg Ge(4, N_{r,c}))$$
for each $r, c \in \{0 \dots N-1\}$.

- Boundary (Halo) Constraints
The empty space immediately surrounding the grid must remain empty. A virtual dead cell at position $(r', c')$ just outside the boundary must not experience a birth.
$$\neg (Ge(3, N_{r',c'}) \wedge \neg Ge(4, N_{r',c'}))$$for each $(r', c')$ in the halo ring where $N_{r',c'}$ contains neighbors inside the grid.

- Global Population ConstraintThe total number of alive cells in the grid must be at least the target population $K$.
$$Ge(K, {ALL})$$
where ${ALL}$ is the set of all variables $\{Cell(0,0) \dots Cell(N-1,N-1)\}$.


## User documentation


Basic usage: 
```
maximum_still_life.py [-h] [-i INPUT] [-o OUTPUT] [-s SOLVER] [-v {0,1}]
```

Command-line options:

* `-h`, `--help` : Show a help message and exit.
* `-n INPUT`, `--input INPUT` : The size of the grid ($n$). Default: 8.
* `-o OUTPUT`, `--output OUTPUT` : Output file for the DIMACS format (i.e. the CNF formula). Default: "formula.cnf"
* `-s SOLVER`, `--solver SOLVER` : The SAT solver to be used. Default: "glucose"
*  `-v {0,1}`, `--verb {0,1}` :  Verbosity of the SAT solver used.

### Output
This program finds the densest still life by sequentially searching using different poulation sizes, and seeing if a still life of that population is possible. It does so using a binary search algorithm, starting from half the total number of tiles ($n/2$), and recursively checking smaller and smaller increments until we fund a maximum population that is satifsiable.

The script will print to the terminal which population size it is currently trying to solve for, and whether it is successful (SAT) or not (UNSAT).

If it does find a maximum pattern, It will print it out on an $n \times n$ grid, where alive cells are represented by 'O', and dead cells represented by '.'.

It will then provide the total population number, and the total excecution time.

For example, for $n = 3$, the output would be:

```
Checking population >= 4...
SAT.
Checking population >= 7...
UNSAT.
Checking population >= 5...
SAT.
Checking population >= 6...
SAT.

MAXIMUM FOUND: 6

Grid Size: 3x3
. O O 
O . O 
O O . 
Total Population: 6

Total excecution time: 0.0517 seconds
```

## Example instances

Any value of $n$ between 2 and 10 will run in a reasonable amount of time. 

There will always be a densest still life pattern for $n \geq 2$.

## Experiments

All experiments were run on an AMD Ryzen 7 7735HS CPU, with 16 GB RAM on Ubuntu inside WSL (Windows 11). Time was measured with python's built in time library.

The only values of $n$ that are unsatisfiable are $n=0$ and $n=1$. 

Values between 2 and 10 excecute in under 10 seconds.


| *n* | *time (s)* | *population* |
|------------:|:-----------|:-----------:|
|   2|  0.0331 | 4
|  3 |  0.0569 | 6
5|0.1419|16
7|0.9435|28
8|1.3224|36
9|5.2951|43
10|9.6752|54
11|29.4762|64
12|97.2295|76


